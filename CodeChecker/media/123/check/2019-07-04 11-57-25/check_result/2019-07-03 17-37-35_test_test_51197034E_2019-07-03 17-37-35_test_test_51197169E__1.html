<span style="background-color: red">#include&lt;bits/stdc++.h&gt;</span></br>
<span style="background-color: greenyellow">#defineintlonglong</span></br>
<span style="background-color: greenyellow">#definefor0(i,n)for(inti=0;i&lt;n;i++)</span></br>
<span style="background-color: write">#defineiter(c)for(autoit=c.begin();it!=c.end();it++)</span></br>
<span style="background-color: write">#defineiter2(c)for(autoit2=c.begin();it2!=c.end();it2++)</span></br>
<span style="background-color: write">#definepbpush_back</span></br>
<span style="background-color: write">#definems(a,z)memset(a,z,sizeof(a));</span></br>
<span style="background-color: write">#definempmake_pair</span></br>
<span style="background-color: write">#definexfirst</span></br>
<span style="background-color: write">#defineysecond</span></br>
<span style="background-color: write">#definesqr(x)1ll*(x)*(x)</span></br>
<span style="background-color: write">#definemax(a,b)((a)&gt;(b)?(a):(b))</span></br>
<span style="background-color: write">#definemin(a,b)((a)&lt;(b)?(a):(b))</span></br>
<span style="background-color: write">#defineall(a)a.begin(),a.end()</span></br>
<span style="background-color: write">#definesz(x)(int)(x).size()</span></br>
<span style="background-color: write">#definepmod(x,m)(((x)%(m)+m)%m)</span></br>
<span style="background-color: write">#ifdefint</span></br>
<span style="background-color: write">#defineread(x)scanf("%i64d",&x);</span></br>
<span style="background-color: yellow">#else</span></br>
<span style="background-color: write">#defineread(x)scanf("%d",&x);</span></br>
<span style="background-color: write">#endif</span></br>
<span style="background-color: write">#ifdefdebug</span></br>
<span style="background-color: greenyellow">#definenlcout&lt;&lt;"\n";</span></br>
<span style="background-color: write">#definepr(x)cout&lt;&lt;(x)&lt;&lt;"";</span></br>
<span style="background-color: write">#defineprl(x)cout&lt;&lt;#x"="&lt;&lt;x&lt;&lt;endl;</span></br>
<span style="background-color: write">#defineprp(x)cout&lt;&lt;"("&lt;&lt;(x).first&lt;&lt;""&lt;&lt;(x).second&lt;&lt;")";</span></br>
<span style="background-color: write">#defineprintv(v){for(int_=0;_&lt;sz(v);_++)cout&lt;&lt;v[_]&lt;&lt;"";cout&lt;&lt;"\n";}</span></br>
<span style="background-color: write">#defineprinta(a,s){for(int_=0;_&lt;s;_++)cout&lt;&lt;a[_]&lt;&lt;"";cout&lt;&lt;"\n";}</span></br>
<span style="background-color: write">#defineprint2d(a,m,n){for(int_=0;_&lt;m;_++){for(int__=0;__&lt;n;__++)cout&lt;&lt;a[_][__]&lt;&lt;"";cout&lt;&lt;"\n";}cout&lt;&lt;"\n";}</span></br>
<span style="background-color: write">#definepriter(v)iter(v){pr(*it)}nl</span></br>
<span style="background-color: write">#definedebugcout&lt;&lt;"okatline"&lt;&lt;__line__&lt;&lt;endl;</span></br>
<span style="background-color: yellow">#else</span></br>
<span style="background-color: write">#definenl</span></br>
<span style="background-color: write">#definepr(x)</span></br>
<span style="background-color: write">#defineprl(x)</span></br>
<span style="background-color: write">#defineprp(x)</span></br>
<span style="background-color: write">#defineprintv(v)</span></br>
<span style="background-color: write">#defineprinta(a,s)</span></br>
<span style="background-color: write">#defineprint2d(a,m,n)</span></br>
<span style="background-color: write">#definepriter(v)</span></br>
<span style="background-color: write">#definedebug</span></br>
<span style="background-color: write">#endif</span></br>
<span style="background-color: write">#definemaxn100000</span></br>
<span style="background-color: red">usingnamespacestd;</span></br>
<span style="background-color: write">typedeflonglongll;</span></br>
<span style="background-color: greenyellow">constintinf=2147483647;</span></br>
<span style="background-color: write">constlonglonginfl=9223372036854775807ll;</span></br>
<span style="background-color: write">constdoubleepsilon=0.00000001;</span></br>
<span style="background-color: write">constlonglongmod=1000000007;</span></br>
<span style="background-color: write">intk[maxn+5],arr[maxn+5];</span></br>
<span style="background-color: write">intslack_vals[maxn+5];</span></br>
<span style="background-color: write">#defineq_op(x1,x2)((x1)+(x2))</span></br>
<span style="background-color: write">#defineupd_op(x1,x2)(x1+x2)</span></br>
<span style="background-color: write">#definerange_op(x,len)((x)*(len))</span></br>
<span style="background-color: write">#defineidentity0</span></br>
<span style="background-color: write">#defineno_lazy-1</span></br>
<span style="background-color: write">template&lt;classdata_type&gt;</span></br>
<span style="background-color: write">classsegmenttree</span></br>
<span style="background-color: write">{</span>
<span style="background-color: write">public:</span></br>
<span style="background-color: write">structnode</span></br>
<span style="background-color: write">{</span>
<span style="background-color: yellow">intl,r;</span></br>
<span style="background-color: write">data_typex;</span></br>
<span style="background-color: write">data_typelazy;</span></br>
<span style="background-color: write">node*left_child,*right_child;</span></br>
<span style="background-color: write">node(intl,intr):l(l),r(r),x(identity),lazy(no_lazy),left_child(nullptr),right_child(nullptr)</span></br>
<span style="background-color: greenyellow">{}</span></br>
<span style="background-color: write">};</span>
<span style="background-color: write">node*root;</span></br>
<span style="background-color: write">segmenttree(){}</span></br>
<span style="background-color: write">/***</span></br>
<span style="background-color: write">constructsandinitializesanewsegmenttreefromtheunderlyingarrayarr</span></br>
<span style="background-color: greenyellow">***/</span></br>
<span style="background-color: write">segmenttree(intl,intr,data_type*arr)</span></br>
<span style="background-color: write">{</span>
<span style="background-color: write">root=construct(l,r,arr);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">node*construct(intl,intr,data_type*arr)</span></br>
<span style="background-color: write">{</span>
<span style="background-color: write">node*nd=newnode(l,r);</span></br>
<span style="background-color: red">if(l==r){</span></br>
<span style="background-color: write">nd-&gt;x=arr[l];</span></br>
<span style="background-color: write">}</span>
<span style="background-color: red">else{</span></br>
<span style="background-color: write">node*left_child=construct(l,(l+r)/2,arr);</span></br>
<span style="background-color: write">node*right_child=construct((l+r)/2+1,r,arr);</span></br>
<span style="background-color: write">nd-&gt;left_child=left_child;</span></br>
<span style="background-color: write">nd-&gt;right_child=right_child;</span></br>
<span style="background-color: write">nd-&gt;x=q_op(left_child-&gt;x,right_child-&gt;x);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: red">returnnd;</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">~segmenttree(){</span></br>
<span style="background-color: write">destruct(root);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">voiddestruct(node*nd){</span></br>
<span style="background-color: write">if(nd-&gt;left_child)</span></br>
<span style="background-color: write">destruct(nd-&gt;left_child);</span></br>
<span style="background-color: write">if(nd-&gt;right_child)</span></br>
<span style="background-color: write">destruct(nd-&gt;right_child);</span></br>
<span style="background-color: write">deletend;</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">voidpush_lazy(node*cur)</span></br>
<span style="background-color: write">{</span>
<span style="background-color: write">if(cur-&gt;left_child-&gt;lazy==no_lazy)</span></br>
<span style="background-color: write">cur-&gt;left_child-&gt;lazy=cur-&gt;lazy;</span></br>
<span style="background-color: write">else</span></br>
<span style="background-color: write">cur-&gt;left_child-&gt;lazy=upd_op(cur-&gt;left_child-&gt;lazy,cur-&gt;lazy);</span></br>
<span style="background-color: write">cur-&gt;left_child-&gt;x=upd_op(cur-&gt;left_child-&gt;x,</span></br>
<span style="background-color: write">range_op(cur-&gt;lazy,cur-&gt;left_child-&gt;r-cur-&gt;left_child-&gt;l+1));</span></br>
<span style="background-color: write">if(cur-&gt;right_child-&gt;lazy==no_lazy)</span></br>
<span style="background-color: write">cur-&gt;right_child-&gt;lazy=cur-&gt;lazy;</span></br>
<span style="background-color: write">else</span></br>
<span style="background-color: write">cur-&gt;right_child-&gt;lazy=upd_op(cur-&gt;right_child-&gt;lazy,cur-&gt;lazy);</span></br>
<span style="background-color: write">cur-&gt;right_child-&gt;x=upd_op(cur-&gt;right_child-&gt;x,</span></br>
<span style="background-color: write">range_op(cur-&gt;lazy,cur-&gt;right_child-&gt;r-cur-&gt;right_child-&gt;l+1));</span></br>
<span style="background-color: greenyellow">cur-&gt;lazy=no_lazy;</span></br>
<span style="background-color: write">assert(cur-&gt;x==q_op(cur-&gt;right_child-&gt;x,cur-&gt;left_child-&gt;x));</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">/***</span></br>
<span style="background-color: write">returnq_opofrangel..rinclusive</span></br>
<span style="background-color: greenyellow">***/</span></br>
<span style="background-color: write">data_typequery(intl,intr)</span></br>
<span style="background-color: write">{</span>
<span style="background-color: greenyellow">if(r&lt;l)return0;</span></br>
<span style="background-color: write">returnquery(l,r,root);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">data_typequery(intl,intr,node*cur)</span></br>
<span style="background-color: write">{</span>
<span style="background-color: greenyellow">if(l&lt;=cur-&gt;l&&cur-&gt;r&lt;=r){</span></br>
<span style="background-color: write">assert(l==cur-&gt;l);</span></br>
<span style="background-color: write">assert(r==cur-&gt;r);</span></br>
<span style="background-color: greenyellow">returncur-&gt;x;</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">else{</span></br>
<span style="background-color: write">data_typexl=identity,xr=identity;</span></br>
<span style="background-color: write">if(cur-&gt;lazy!=no_lazy){</span></br>
<span style="background-color: write">push_lazy(cur);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">if(l&lt;=cur-&gt;left_child-&gt;r){</span></br>
<span style="background-color: write">xl=query(l,min(cur-&gt;left_child-&gt;r,r),cur-&gt;left_child);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">if(r&gt;=cur-&gt;right_child-&gt;l){</span></br>
<span style="background-color: write">xr=query(max(cur-&gt;right_child-&gt;l,l),r,cur-&gt;right_child);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: greenyellow">returnq_op(xl,xr);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">}</span>
<span style="background-color: write">/***</span></br>
<span style="background-color: write">applyupd_opwithxtoallitemsinrangel..rinclusive</span></br>
<span style="background-color: write">***/</span></br>
<span style="background-color: greenyellow">voidupdate(intl,intr,data_typex)</span></br>
<span style="background-color: write">{</span>
<span style="background-color: greenyellow">if(r&lt;l)return;</span></br>
<span style="background-color: write">pr("update")pr(l)pr(r)pr(x)nl</span></br>
<span style="background-color: greenyellow">update(l,r,x,root);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">voidupdate(intl,intr,data_typex,node*cur)</span></br>
<span style="background-color: write">{</span>
<span style="background-color: write">if(l&lt;=cur-&gt;l&&cur-&gt;r&lt;=r){</span></br>
<span style="background-color: write">#ifdefdebug</span></br>
<span style="background-color: write">assert(l==cur-&gt;l);</span></br>
<span style="background-color: write">assert(r==cur-&gt;r);</span></br>
<span style="background-color: write">#endif</span></br>
<span style="background-color: red">if(l==r){</span></br>
<span style="background-color: write">cur-&gt;x=upd_op(cur-&gt;x,x);</span></br>
<span style="background-color: write">cur-&gt;lazy=no_lazy;</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">else{</span></br>
<span style="background-color: write">cur-&gt;x=upd_op(cur-&gt;x,range_op(x,r-l+1));</span></br>
<span style="background-color: write">if(cur-&gt;lazy==no_lazy)</span></br>
<span style="background-color: write">cur-&gt;lazy=x;</span></br>
<span style="background-color: write">else</span></br>
<span style="background-color: write">cur-&gt;lazy=upd_op(cur-&gt;lazy,x);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">}</span>
<span style="background-color: write">else{</span></br>
<span style="background-color: write">if(cur-&gt;lazy!=no_lazy){</span></br>
<span style="background-color: write">push_lazy(cur);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">if(l&lt;=cur-&gt;left_child-&gt;r){</span></br>
<span style="background-color: write">update(l,min(cur-&gt;left_child-&gt;r,r),x,cur-&gt;left_child);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">if(r&gt;=cur-&gt;right_child-&gt;l){</span></br>
<span style="background-color: write">update(max(cur-&gt;right_child-&gt;l,l),r,x,cur-&gt;right_child);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">cur-&gt;x=q_op(cur-&gt;left_child-&gt;x,cur-&gt;right_child-&gt;x);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">}</span>
<span style="background-color: write">};</span>
<span style="background-color: yellow">int32_tmain()</span></br>
<span style="background-color: write">{</span>
<span style="background-color: write">#ifdefdebug</span></br>
<span style="background-color: write">#endif</span></br>
<span style="background-color: greenyellow">intn;</span></br>
<span style="background-color: yellow">cin&gt;&gt;n;</span></br>
<span style="background-color: write">for0(i,n){</span></br>
<span style="background-color: write">read(arr[i]);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">for0(i,n-1){</span></br>
<span style="background-color: write">read(k[i]);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">set&lt;int&gt;slacks;</span></br>
<span style="background-color: write">ms(slack_vals,0);</span></br>
<span style="background-color: red">for(inti=1;i&lt;n;i++){</span></br>
<span style="background-color: write">ints=arr[i]-(arr[i-1]+k[i-1]);</span></br>
<span style="background-color: greenyellow">if(s&gt;0){</span></br>
<span style="background-color: write">slacks.insert(i);</span></br>
<span style="background-color: write">slack_vals[i]=s;</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">}</span>
<span style="background-color: write">printa(slack_vals,n);</span></br>
<span style="background-color: write">for(ints:slacks){pr(s)}nl</span></br>
<span style="background-color: write">nl</span></br>
<span style="background-color: write">segmenttree&lt;ll&gt;segtree=segmenttree&lt;ll&gt;(0,n-1,arr);</span></br>
<span style="background-color: greenyellow">intq;</span></br>
<span style="background-color: yellow">cin&gt;&gt;q;</span></br>
<span style="background-color: write">for0(i,q){</span></br>
<span style="background-color: write">stringtype;</span></br>
<span style="background-color: write">cin&gt;&gt;type;</span></br>
<span style="background-color: greenyellow">if(type=="+"){</span></br>
<span style="background-color: yellow">inti,x;</span></br>
<span style="background-color: write">read(i);read(x);i--;</span></br>
<span style="background-color: write">pr("update")pr(i)pr(x)nl</span></br>
<span style="background-color: write">intprev=i;</span></br>
<span style="background-color: write">set&lt;int&gt;::iteratorit=slacks.lower_bound(i+1);</span></br>
<span style="background-color: write">intdelta=x;</span></br>
<span style="background-color: write">while(it!=slacks.end()anddelta&gt;0){</span></br>
<span style="background-color: write">intl=prev;</span></br>
<span style="background-color: greenyellow">intr=*it-1;</span></br>
<span style="background-color: write">pr(l)pr(r)pr(delta)nl</span></br>
<span style="background-color: write">segtree.update(l,r,delta);</span></br>
<span style="background-color: write">prev=*it;</span></br>
<span style="background-color: write">if(slack_vals[*it]&gt;delta){</span></br>
<span style="background-color: write">slack_vals[*it]-=delta;</span></br>
<span style="background-color: write">it++;</span></br>
<span style="background-color: write">delta=0;</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">else{</span></br>
<span style="background-color: write">delta-=slack_vals[*it];</span></br>
<span style="background-color: write">slack_vals[*it]=0;</span></br>
<span style="background-color: write">it=slacks.erase(it);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">#ifdefdebug</span></br>
<span style="background-color: write">printa(slack_vals,n)</span></br>
<span style="background-color: write">for(ints:slacks){pr(s)}nl</span></br>
<span style="background-color: write">nl</span></br>
<span style="background-color: write">#endif</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">if(slack_vals[i]==0){</span></br>
<span style="background-color: write">slacks.insert(i);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">slack_vals[i]+=x;</span></br>
<span style="background-color: greenyellow">if(delta&gt;0){</span></br>
<span style="background-color: write">segtree.update(prev,n-1,delta);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">#ifdefdebug</span></br>
<span style="background-color: write">printa(slack_vals,n)</span></br>
<span style="background-color: write">for(ints:slacks){pr(s)}nl</span></br>
<span style="background-color: write">nl</span></br>
<span style="background-color: write">#endif</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">else{</span></br>
<span style="background-color: write">intl,r;</span></br>
<span style="background-color: write">read(l);read(r);l--;r--;</span></br>
<span style="background-color: write">pr("sum")pr(l)pr(r)nl</span></br>
<span style="background-color: write">llans=segtree.query(l,r);</span></br>
<span style="background-color: write">cout&lt;&lt;ans&lt;&lt;endl;</span></br>
<span style="background-color: write">nl</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">}</span>
<span style="background-color: red">return0;</span></br>
<span style="background-color: write">}</span>
