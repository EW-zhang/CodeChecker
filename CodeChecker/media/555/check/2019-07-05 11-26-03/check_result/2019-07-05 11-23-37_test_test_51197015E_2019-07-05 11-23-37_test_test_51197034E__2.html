<span style="background-color: yellow">#include&lt;bits/stdc++.h&gt;</span></br>
<span style="background-color: greenyellow">#defineintlonglong</span></br>
<span style="background-color: greenyellow">#definefor0(i,n)for(inti=0;i&lt;n;i++)</span></br>
<span style="background-color: white">#defineiter(c)for(autoit=c.begin();it!=c.end();it++)</span></br>
<span style="background-color: white">#defineiter2(c)for(autoit2=c.begin();it2!=c.end();it2++)</span></br>
<span style="background-color: white">#definepbpush_back</span></br>
<span style="background-color: white">#definems(a,z)memset(a,z,sizeof(a));</span></br>
<span style="background-color: white">#definempmake_pair</span></br>
<span style="background-color: white">#definexfirst</span></br>
<span style="background-color: white">#defineysecond</span></br>
<span style="background-color: red">#definesqr(x)1ll*(x)*(x)</span></br>
<span style="background-color: white">#definemax(a,b)((a)&gt;(b)?(a):(b))</span></br>
<span style="background-color: white">#definemin(a,b)((a)&lt;(b)?(a):(b))</span></br>
<span style="background-color: white">#defineall(a)a.begin(),a.end()</span></br>
<span style="background-color: white">#definesz(x)(int)(x).size()</span></br>
<span style="background-color: white">#definepmod(x,m)(((x)%(m)+m)%m)</span></br>
<span style="background-color: white">#ifdefint</span></br>
<span style="background-color: white">#defineread(x)scanf("%i64d",&x);</span></br>
<span style="background-color: yellow">#else</span></br>
<span style="background-color: white">#defineread(x)scanf("%d",&x);</span></br>
<span style="background-color: white">#endif</span></br>
<span style="background-color: white">#ifdefdebug</span></br>
<span style="background-color: white">#definenlcout&lt;&lt;"\n";</span></br>
<span style="background-color: white">#definepr(x)cout&lt;&lt;(x)&lt;&lt;"";</span></br>
<span style="background-color: white">#defineprl(x)cout&lt;&lt;#x"="&lt;&lt;x&lt;&lt;endl;</span></br>
<span style="background-color: white">#defineprp(x)cout&lt;&lt;"("&lt;&lt;(x).first&lt;&lt;""&lt;&lt;(x).second&lt;&lt;")";</span></br>
<span style="background-color: white">#defineprintv(v){for(int_=0;_&lt;sz(v);_++)cout&lt;&lt;v[_]&lt;&lt;"";cout&lt;&lt;"\n";}</span></br>
<span style="background-color: white">#defineprinta(a,s){for(int_=0;_&lt;s;_++)cout&lt;&lt;a[_]&lt;&lt;"";cout&lt;&lt;"\n";}</span></br>
<span style="background-color: white">#defineprint2d(a,m,n){for(int_=0;_&lt;m;_++){for(int__=0;__&lt;n;__++)cout&lt;&lt;a[_][__]&lt;&lt;"";cout&lt;&lt;"\n";}cout&lt;&lt;"\n";}</span></br>
<span style="background-color: white">#definepriter(v)iter(v){pr(*it)}nl</span></br>
<span style="background-color: white">#definedebugcout&lt;&lt;"okatline"&lt;&lt;__line__&lt;&lt;endl;</span></br>
<span style="background-color: yellow">#else</span></br>
<span style="background-color: white">#definenl</span></br>
<span style="background-color: white">#definepr(x)</span></br>
<span style="background-color: white">#defineprl(x)</span></br>
<span style="background-color: white">#defineprp(x)</span></br>
<span style="background-color: white">#defineprintv(v)</span></br>
<span style="background-color: white">#defineprinta(a,s)</span></br>
<span style="background-color: white">#defineprint2d(a,m,n)</span></br>
<span style="background-color: white">#definepriter(v)</span></br>
<span style="background-color: white">#definedebug</span></br>
<span style="background-color: white">#endif</span></br>
<span style="background-color: white">#definemaxn100000</span></br>
<span style="background-color: red">usingnamespacestd;</span></br>
<span style="background-color: white">typedeflonglongll;</span></br>
<span style="background-color: greenyellow">constintinf=2147483647;</span></br>
<span style="background-color: white">constlonglonginfl=9223372036854775807ll;</span></br>
<span style="background-color: greenyellow">constdoubleepsilon=0.00000001;</span></br>
<span style="background-color: white">constlonglongmod=1000000007;</span></br>
<span style="background-color: white">intk[maxn+5],arr[maxn+5];</span></br>
<span style="background-color: white">intslack_vals[maxn+5];</span></br>
<span style="background-color: white">#defineq_op(x1,x2)((x1)+(x2))</span></br>
<span style="background-color: white">#defineupd_op(x1,x2)(x1+x2)</span></br>
<span style="background-color: white">#definerange_op(x,len)((x)*(len))</span></br>
<span style="background-color: white">#defineidentity0</span></br>
<span style="background-color: white">#defineno_lazy-1</span></br>
<span style="background-color: white">template&lt;classdata_type&gt;</span></br>
<span style="background-color: white">classsegmenttree</span></br>
<span style="background-color: write">{</span>
<span style="background-color: red">public:</span></br>
<span style="background-color: greenyellow">structnode</span></br>
<span style="background-color: write">{</span>
<span style="background-color: white">intl,r;</span></br>
<span style="background-color: white">data_typex;</span></br>
<span style="background-color: white">data_typelazy;</span></br>
<span style="background-color: white">node*left_child,*right_child;</span></br>
<span style="background-color: white">node(intl,intr):l(l),r(r),x(identity),lazy(no_lazy),left_child(nullptr),right_child(nullptr)</span></br>
<span style="background-color: greenyellow">{}</span></br>
<span style="background-color: write">};</span>
<span style="background-color: white">node*root;</span></br>
<span style="background-color: greenyellow">segmenttree(){}</span></br>
<span style="background-color: white">/***</span></br>
<span style="background-color: white">constructsandinitializesanewsegmenttreefromtheunderlyingarrayarr</span></br>
<span style="background-color: white">***/</span></br>
<span style="background-color: white">segmenttree(intl,intr,data_type*arr)</span></br>
<span style="background-color: write">{</span>
<span style="background-color: white">root=construct(l,r,arr);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: white">node*construct(intl,intr,data_type*arr)</span></br>
<span style="background-color: write">{</span>
<span style="background-color: white">node*nd=newnode(l,r);</span></br>
<span style="background-color: yellow">if(l==r){</span></br>
<span style="background-color: white">nd-&gt;x=arr[l];</span></br>
<span style="background-color: write">}</span>
<span style="background-color: white">else{</span></br>
<span style="background-color: white">node*left_child=construct(l,(l+r)/2,arr);</span></br>
<span style="background-color: white">node*right_child=construct((l+r)/2+1,r,arr);</span></br>
<span style="background-color: white">nd-&gt;left_child=left_child;</span></br>
<span style="background-color: white">nd-&gt;right_child=right_child;</span></br>
<span style="background-color: white">nd-&gt;x=q_op(left_child-&gt;x,right_child-&gt;x);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: greenyellow">returnnd;</span></br>
<span style="background-color: write">}</span>
<span style="background-color: white">~segmenttree(){</span></br>
<span style="background-color: white">destruct(root);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: white">voiddestruct(node*nd){</span></br>
<span style="background-color: white">if(nd-&gt;left_child)</span></br>
<span style="background-color: white">destruct(nd-&gt;left_child);</span></br>
<span style="background-color: white">if(nd-&gt;right_child)</span></br>
<span style="background-color: white">destruct(nd-&gt;right_child);</span></br>
<span style="background-color: white">deletend;</span></br>
<span style="background-color: write">}</span>
<span style="background-color: greenyellow">voidpush_lazy(node*cur)</span></br>
<span style="background-color: write">{</span>
<span style="background-color: white">if(cur-&gt;left_child-&gt;lazy==no_lazy)</span></br>
<span style="background-color: white">cur-&gt;left_child-&gt;lazy=cur-&gt;lazy;</span></br>
<span style="background-color: white">else</span></br>
<span style="background-color: white">cur-&gt;left_child-&gt;lazy=upd_op(cur-&gt;left_child-&gt;lazy,cur-&gt;lazy);</span></br>
<span style="background-color: white">cur-&gt;left_child-&gt;x=upd_op(cur-&gt;left_child-&gt;x,</span></br>
<span style="background-color: white">range_op(cur-&gt;lazy,cur-&gt;left_child-&gt;r-cur-&gt;left_child-&gt;l+1));</span></br>
<span style="background-color: white">if(cur-&gt;right_child-&gt;lazy==no_lazy)</span></br>
<span style="background-color: white">cur-&gt;right_child-&gt;lazy=cur-&gt;lazy;</span></br>
<span style="background-color: white">else</span></br>
<span style="background-color: white">cur-&gt;right_child-&gt;lazy=upd_op(cur-&gt;right_child-&gt;lazy,cur-&gt;lazy);</span></br>
<span style="background-color: white">cur-&gt;right_child-&gt;x=upd_op(cur-&gt;right_child-&gt;x,</span></br>
<span style="background-color: white">range_op(cur-&gt;lazy,cur-&gt;right_child-&gt;r-cur-&gt;right_child-&gt;l+1));</span></br>
<span style="background-color: white">cur-&gt;lazy=no_lazy;</span></br>
<span style="background-color: white">assert(cur-&gt;x==q_op(cur-&gt;right_child-&gt;x,cur-&gt;left_child-&gt;x));</span></br>
<span style="background-color: write">}</span>
<span style="background-color: white">/***</span></br>
<span style="background-color: white">returnq_opofrangel..rinclusive</span></br>
<span style="background-color: white">***/</span></br>
<span style="background-color: white">data_typequery(intl,intr)</span></br>
<span style="background-color: write">{</span>
<span style="background-color: white">if(r&lt;l)return0;</span></br>
<span style="background-color: white">returnquery(l,r,root);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: white">data_typequery(intl,intr,node*cur)</span></br>
<span style="background-color: write">{</span>
<span style="background-color: greenyellow">if(l&lt;=cur-&gt;l&&cur-&gt;r&lt;=r){</span></br>
<span style="background-color: white">assert(l==cur-&gt;l);</span></br>
<span style="background-color: white">assert(r==cur-&gt;r);</span></br>
<span style="background-color: greenyellow">returncur-&gt;x;</span></br>
<span style="background-color: write">}</span>
<span style="background-color: white">else{</span></br>
<span style="background-color: white">data_typexl=identity,xr=identity;</span></br>
<span style="background-color: white">if(cur-&gt;lazy!=no_lazy){</span></br>
<span style="background-color: greenyellow">push_lazy(cur);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: white">if(l&lt;=cur-&gt;left_child-&gt;r){</span></br>
<span style="background-color: white">xl=query(l,min(cur-&gt;left_child-&gt;r,r),cur-&gt;left_child);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: white">if(r&gt;=cur-&gt;right_child-&gt;l){</span></br>
<span style="background-color: white">xr=query(max(cur-&gt;right_child-&gt;l,l),r,cur-&gt;right_child);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: greenyellow">returnq_op(xl,xr);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">}</span>
<span style="background-color: white">/***</span></br>
<span style="background-color: white">applyupd_opwithxtoallitemsinrangel..rinclusive</span></br>
<span style="background-color: white">***/</span></br>
<span style="background-color: white">voidupdate(intl,intr,data_typex)</span></br>
<span style="background-color: write">{</span>
<span style="background-color: greenyellow">if(r&lt;l)return;</span></br>
<span style="background-color: white">pr("update")pr(l)pr(r)pr(x)nl</span></br>
<span style="background-color: greenyellow">update(l,r,x,root);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: greenyellow">voidupdate(intl,intr,data_typex,node*cur)</span></br>
<span style="background-color: write">{</span>
<span style="background-color: greenyellow">if(l&lt;=cur-&gt;l&&cur-&gt;r&lt;=r){</span></br>
<span style="background-color: white">#ifdefdebug</span></br>
<span style="background-color: white">assert(l==cur-&gt;l);</span></br>
<span style="background-color: white">assert(r==cur-&gt;r);</span></br>
<span style="background-color: white">#endif</span></br>
<span style="background-color: greenyellow">if(l==r){</span></br>
<span style="background-color: white">cur-&gt;x=upd_op(cur-&gt;x,x);</span></br>
<span style="background-color: white">cur-&gt;lazy=no_lazy;</span></br>
<span style="background-color: write">}</span>
<span style="background-color: white">else{</span></br>
<span style="background-color: white">cur-&gt;x=upd_op(cur-&gt;x,range_op(x,r-l+1));</span></br>
<span style="background-color: white">if(cur-&gt;lazy==no_lazy)</span></br>
<span style="background-color: white">cur-&gt;lazy=x;</span></br>
<span style="background-color: white">else</span></br>
<span style="background-color: white">cur-&gt;lazy=upd_op(cur-&gt;lazy,x);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">}</span>
<span style="background-color: white">else{</span></br>
<span style="background-color: white">if(cur-&gt;lazy!=no_lazy){</span></br>
<span style="background-color: greenyellow">push_lazy(cur);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: white">if(l&lt;=cur-&gt;left_child-&gt;r){</span></br>
<span style="background-color: white">update(l,min(cur-&gt;left_child-&gt;r,r),x,cur-&gt;left_child);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: white">if(r&gt;=cur-&gt;right_child-&gt;l){</span></br>
<span style="background-color: white">update(max(cur-&gt;right_child-&gt;l,l),r,x,cur-&gt;right_child);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: white">cur-&gt;x=q_op(cur-&gt;left_child-&gt;x,cur-&gt;right_child-&gt;x);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">}</span>
<span style="background-color: write">};</span>
<span style="background-color: yellow">int32_tmain()</span></br>
<span style="background-color: write">{</span>
<span style="background-color: white">#ifdefdebug</span></br>
<span style="background-color: white">#endif</span></br>
<span style="background-color: greenyellow">intn;</span></br>
<span style="background-color: red">cin&gt;&gt;n;</span></br>
<span style="background-color: white">for0(i,n){</span></br>
<span style="background-color: white">read(arr[i]);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: greenyellow">for0(i,n-1){</span></br>
<span style="background-color: greenyellow">read(k[i]);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: white">set&lt;int&gt;slacks;</span></br>
<span style="background-color: white">ms(slack_vals,0);</span></br>
<span style="background-color: yellow">for(inti=1;i&lt;n;i++){</span></br>
<span style="background-color: white">ints=arr[i]-(arr[i-1]+k[i-1]);</span></br>
<span style="background-color: greenyellow">if(s&gt;0){</span></br>
<span style="background-color: yellow">slacks.insert(i);</span></br>
<span style="background-color: white">slack_vals[i]=s;</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">}</span>
<span style="background-color: white">printa(slack_vals,n);</span></br>
<span style="background-color: white">for(ints:slacks){pr(s)}nl</span></br>
<span style="background-color: white">nl</span></br>
<span style="background-color: white">segmenttree&lt;ll&gt;segtree=segmenttree&lt;ll&gt;(0,n-1,arr);</span></br>
<span style="background-color: greenyellow">intq;</span></br>
<span style="background-color: yellow">cin&gt;&gt;q;</span></br>
<span style="background-color: greenyellow">for0(i,q){</span></br>
<span style="background-color: white">stringtype;</span></br>
<span style="background-color: yellow">cin&gt;&gt;type;</span></br>
<span style="background-color: white">if(type=="+"){</span></br>
<span style="background-color: greenyellow">inti,x;</span></br>
<span style="background-color: white">read(i);read(x);i--;</span></br>
<span style="background-color: white">pr("update")pr(i)pr(x)nl</span></br>
<span style="background-color: white">intprev=i;</span></br>
<span style="background-color: greenyellow">set&lt;int&gt;::iteratorit=slacks.lower_bound(i+1);</span></br>
<span style="background-color: white">intdelta=x;</span></br>
<span style="background-color: greenyellow">while(it!=slacks.end()anddelta&gt;0){</span></br>
<span style="background-color: white">intl=prev;</span></br>
<span style="background-color: white">intr=*it-1;</span></br>
<span style="background-color: white">pr(l)pr(r)pr(delta)nl</span></br>
<span style="background-color: greenyellow">segtree.update(l,r,delta);</span></br>
<span style="background-color: white">prev=*it;</span></br>
<span style="background-color: white">if(slack_vals[*it]&gt;delta){</span></br>
<span style="background-color: white">slack_vals[*it]-=delta;</span></br>
<span style="background-color: red">it++;</span></br>
<span style="background-color: white">delta=0;</span></br>
<span style="background-color: write">}</span>
<span style="background-color: white">else{</span></br>
<span style="background-color: white">delta-=slack_vals[*it];</span></br>
<span style="background-color: white">slack_vals[*it]=0;</span></br>
<span style="background-color: white">it=slacks.erase(it);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: white">#ifdefdebug</span></br>
<span style="background-color: white">printa(slack_vals,n)</span></br>
<span style="background-color: white">for(ints:slacks){pr(s)}nl</span></br>
<span style="background-color: white">nl</span></br>
<span style="background-color: white">#endif</span></br>
<span style="background-color: write">}</span>
<span style="background-color: white">if(slack_vals[i]==0){</span></br>
<span style="background-color: greenyellow">slacks.insert(i);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: white">slack_vals[i]+=x;</span></br>
<span style="background-color: greenyellow">if(delta&gt;0){</span></br>
<span style="background-color: white">segtree.update(prev,n-1,delta);</span></br>
<span style="background-color: write">}</span>
<span style="background-color: white">#ifdefdebug</span></br>
<span style="background-color: white">printa(slack_vals,n)</span></br>
<span style="background-color: white">for(ints:slacks){pr(s)}nl</span></br>
<span style="background-color: white">nl</span></br>
<span style="background-color: white">#endif</span></br>
<span style="background-color: write">}</span>
<span style="background-color: white">else{</span></br>
<span style="background-color: white">intl,r;</span></br>
<span style="background-color: white">read(l);read(r);l--;r--;</span></br>
<span style="background-color: white">pr("sum")pr(l)pr(r)nl</span></br>
<span style="background-color: white">llans=segtree.query(l,r);</span></br>
<span style="background-color: white">cout&lt;&lt;ans&lt;&lt;endl;</span></br>
<span style="background-color: white">nl</span></br>
<span style="background-color: write">}</span>
<span style="background-color: write">}</span>
<span style="background-color: greenyellow">return0;</span></br>
<span style="background-color: write">}</span>
